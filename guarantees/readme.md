# Гарантии доставки

В данной задаче Вам надо будет написать логику клиента и сервера с различными
гарантиями доставки.

Для простоты будем считать что один процесс (назовем его sender) только
отправляет сообщения, а другой (receiver) - принимает сообщения и, например,
выводит их пользователю. Передаваемые сообщения могуг быть разного типа, в
зависимости от которого могут требоваться разные гарантии их доставки:

1. Не более одного раза (at most once). Вам надо сделать так, чтобы
повторных записей не было, но все сообщения, которые доставились, были.
2. Не менее одного раза (at least once). Вам надо сделать так, чтобы все
сообщения присутствовали хотя бы один раз.
3. Ровно один раз (exactly once), то есть нет дублей. Вам надо сделать так,
чтобы все сообщения присутствовали ровно один раз в любом порядке.
4. Ровно один раз и с сохранением порядка. Вам надо сделать так, чтобы порядок
отправки сохранился у сообщений, и все сообщения присутствовали ровно один раз.

Во всех пунктах транспорт, лежащий в основе, таков: доставка сообщений не
гарантируется, сообщение может дублироваться, порядок не гарантируется.

Вы можете сказать, что 4 покрывает 1-3 и будете совершенно правы, тем не
менее, мы просим вас написать 1-3 отдельно с минимальным оверхедом для каждого
из пунктов. Если Вы просто напишите 4, мы не зачтём Вам 1-3, так как эти случаи
требуют меньшего количество дополнительных данных и ресурсов.

Если указано, что доставка сообщений не гарантируется, это значит существует
вероятность, что оно не доставится. Тем не менее, гарантируется, что если
попробовать отправить сообщение несколько раз, то сообщение дойдёт с большой
вероятностью (считайте, что в тестах нужно достигнуть вероятности не менее
1 - 2^{-50}, когда как без повторных отправок тест должен падать с вероятностью
хотя бы 2^{-3}). _Подсказка:_ это нужно для пунктов 2-4.

## Задание

Для реализации и тестирования решения используется фреймворк [dslib](../../dslib).
Перед выполнением задания познакомьтесь с описанием фреймворка по сссылке.

В папке [solution](./solution) размещена заготовка для решения в виде двух файлов
[sender](./solution/sender.py) и [receiver](./solution/receiver.py).
Вам также надо будет написать несколько тестов, которые проверяют реализацию пункта 4,
добавив их к уже имеющимся тестам в [test.py](./test.py).

### Сообщение

Класс [Message](../../dslib/message.py) в dslib состоит из типа, заголовков, тела, отправителя и идентификатора.

```python
self._type = message_type
self._headers = headers
self._body = body
self._sender = sender
self._id = message_id
```

Менять можно только заголовки (headers) сообщений, их не надо проверять в тестах.
Если будет изменено что-то другое, это может привести к неработающим тестам или
обнулению баллов. Полагаться на `_id` тоже нельзя, в тестировании оно будет не
`None`, но при обычном запуске будет `None`.

Два сообщения считаются одинаковыми, если в них все поля, кроме `_id` совпадают.
Класс Message уже обладает нужными операторами сравнения и хэширования.

```python
def __eq__(self, other):
  return self._type == other._type and \
         self._headers == other._headers and \
         self._body == other._body and \
         self._sender == other._sender

def __hash__(self):
  return hash(self._type) ^ hash(self._headers) ^ hash(self._body) ^ \
         hash(self._sender)
```

Помимо сообщений, которыми обмениваются между собой процессы, Ваши процессы могут
принимать и отправлять так называемые локальные сообщения. Эти сообщения позволяют
взаимодействовать с процессами извне, передавать им команды, например во время тестов.
У сообщения есть метод `is_local`, который позволяет определить является ли сообщение
локальным.

### Sender

Sender состоит из одного метода, который Вам надо доработать -- метод `run`. Sender
получает сообщения, которые надо отправить receiver-у, через локальные сообщения.
Строки `INFO-[1-4]` обозначают гарантии, которые были сформулированы выше.

Напишите для каждой гарантии под номером n такой код, который не гарантирует
никакую из следующих гарантий n + 1, n + 2 и т.д.

Единственные два метода, которыми можно пользоваться у `_comm` -- методы `send`
и `recv`, для перезапросов указывайте timeout у метода `recv`,
если timeout прошёл, а сообщение не доставилось, это повод для повторной
отправки даже если первое сообщение доставилось потом, учитывайте это. Метод
`recv_local` используется для получения локальных запросов, и он может терять
некоторые нелокальные сообщения (от другого процесса).

```python
def send(self, message, recepient):
  # Send a message to recepient, underlying transport depends on the
  # implementation.
  pass

def recv(self, timeout=None):
  # Recieve a message from server or local testing server. If timeout passes,
  # the result is None, otherwise receiced Message is returned.
  pass

def recv_local(self):
  # Recieve a message from local testing server. Server messages can be lost by
  # this call.
  pass
```

### Receiver

У receiver есть один метод -- `run`, он принимает сообщения от клиента и должен
их обработать с данными гарантиями. Метод `run` может общаться с sender при
помощи вызовов `send` -- эти сообщения также могут дублироваться, пропадать,
клиент должен это правильно обрабатывать.

Полученные сообщения надо пересылать локальному клиенту (тестировщику) --
в первых трёх пунктах это достаточно очевидно, в 4 пункте передавайте сообщения
в нужном порядке -- если что-то пропущено посередине, не передавайте ничего
начиная с этой середины, пока не дождётесь этого "серединного" сообщения.
Передавать такие сообщения надо с помощью метода `.send_local()`. `.send_local()`
доставляет сообщения в том порядке, в котором они были отправлены.

## Тестирование

Установите необходимые зависимости:

```console
$ pip3 install -r requirements.txt
```

__Добавьте корень репозитория в переменную окружения PYTHONPATH и можете
запустить, например__:

```console
$ PYTHONPATH=$ROOT_DIRECTORY_PATH python3 test.py solution
```

Если Вам нужна бОльшая debug информация, добавьте флаг `-d` к тестированию. Если
Вам хочется прогнать тесты несколько раз, укажите число после флага `-n`.

Поднимаются три процесса -- `sender`, `receiver` и `test_server`. Коммуникация между
`sender` и `receiver` происходит через `test_server`, кроме того последний может
читать все локальные сообщения, отправляемые Вашими процессами, в порядке их отправки.

Тесты работают на стороне `test_server`.
Каждый тест гарантировано тестирует только один из пунктов `INFO-[1-4]`.

Разобраться с тестированием, что происходит, как мы подменяем транспорт и что
гарантируем -- Ваша задача. Вы также должны написать тесты, которые проверяют
корректность Вашего 4-го пункта (первые 3 уже написаны). Если тесты недостаточно
покрывают условия, это может привести к снижению оценки. Особенное внимание
обратите на код [тестового сервера](../../dslib/test_server.py).

*Совет:* Перед отправкой запустите Ваш код другую-сотню раз на тестах во
избежание того, что Вам повезло на случайностях.

## Оценка

Задача состоит из 5 пунктов (4 на доставку и 1 на тесты), все из них оцениваются
по 2 балла. Критерии оценки первых четырёх пунктов достаточно прямолинейны,
последний пункт оценивается из покрытия случаев гарантий. Если какие-то
гарантии не тестируются или тестируются не все возможные ошибки и краевые случаи,
то оценка за тесты может быть снижена. Также если Вы используете
случайность, удостоверьтесь, что без повторных запросов тест падает достаточно
часто, скажем, с вероятностью не меньше, чем 2^{-3}. Дробных баллов не
предусмотрено.

Ваше решение должно проходить тесты с вероятностью не менее 1 - 2^{-50}.

Числа весьма условные, сделаны для того, чтобы если мы запустили тесты десятки
тысяч раз, то они не упадут на нашей системе, и мы видели, что условия повторов
запросов действительно работают.

## Сдача

Сдача и проверка решений будет вестись через сервис Gradescope. Вам надо
зарегистрироваться в нём и подключиться к курсу по коду MPV6VW следуя
[этой инструкции](https://help.gradescope.com/article/gi7gm49peg-student-add-course).

Далее зайдите в Assignments, там Вы увидите задачу Guarantees, в которую можно
сдавать только zip архивы. Поместите тесты и решение в архив следующей командой:

```console
$ zip -r solution.zip test.py solution/
```
Желательно также добавить в папку `solution` файл `readme.md` с кратким описанием
Вашего решения и дополнительными комментариями, который также попадет в архив.

Далее сдайте Ваш `solution.zip`. Дождитесь пока отработают Ваши тесты на Вашем решении
(учтите, что это может занять несколько минут из-за нагрузки серверов). Если все тесты
прошли успешно, то решение проставляется 2 балла и решение принимается на ручную проверку.
Если какие-то тесты не прошли, то выставляется 0 баллов, и решение не принимается на
ручную проверку.

Если Вы не смогли что-то реализовать, можете закомментировать некоторые тесты в [test.py](./test.py),
но обязательно отразите почему Вы это сделали в readme-файле. Это сильно упростит нам проверку.

Дедлайн задачи -- __2 недели__, в Gradescope корректно проставлена дата
окончания.
